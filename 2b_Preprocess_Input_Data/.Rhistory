values <- rle_diff$values
run_ends <- cumsum(lengths)
run_starts <- c(1, head(run_ends + 1, -1))
adjacent_runs <- mapply(function(start, len) {
if (values[start]) {
target_rows[run_starts[start]:(run_ends[start])]
} else {
NULL
}
}, seq_along(values), lengths, SIMPLIFY = FALSE)
adjacent_runs <- Filter(Negate(is.null), adjacent_runs)
adjacent_runs <- Filter(function(x) length(x) > 0, adjacent_runs)
if (length(adjacent_runs) > 0) {
longest_run <- adjacent_runs[[which.max(sapply(adjacent_runs, length))]]
subset_df <- percentage_error_vs_intensity_results[longest_run, ]
min_range_row <- subset_df[which.min(subset_df$range_start), ]
good_int_cutoff <- 10^min_range_row$range_start
} else {
good_int_cutoff <- NA
}
} else {
good_int_cutoff <- NA  # No rows with median_expression <= 0.05
}
# Next to plot for each slice what is the max intensity among m0m1m2 to check if
# Function to calculate the maximum mn intensity, considering the source
calculate_max_mn_intensity <- function(row) {
if (row$source == "M0M1M2") {
return(max(c(row$m0_intensity, row$m1_intensity, row$m2_intensity), na.rm = TRUE))
} else {
return(max(c(row$m0_intensity, row$m1_intensity), na.rm = TRUE))
}
}
# Apply the function to each row to calculate the max mn intensity
df_by_slice_combined <- df_by_slice_combined %>%
rowwise() %>%
mutate(max_mn_intensity = calculate_max_mn_intensity(cur_data())) %>%
ungroup()
# Calculate the maximum intensity for each row in df_by_slice_combined
max_intensity_sub_b <- apply(df_by_slice_combined[, c("m0_intensity_sub_b", "m1_intensity_sub_b", "m2_intensity_sub_b")], 1, max, na.rm = TRUE)
# Apply log10 transformation to the maximum intensity values
log_max_intensity_sub_b <- log10(max_intensity_sub_b)
# Sort the log-transformed maximum intensity values
sorted_log_max_intensity_sub_b <- sort(log_max_intensity_sub_b)
# Create the final combined data frame df_by_slice_combined with necessary columns
df_by_slice_combined <- df_by_slice_combined %>%
select(-source)  # Remove the source column if not needed
log_cutoff <- log10(good_int_cutoff)
# Create data frame for plotting and count and calculate statistics
df_ggplot <- data.frame(
Index = seq_along(sorted_log_max_intensity_sub_b),
logMaxIntensity = sorted_log_max_intensity_sub_b
)
num_above_cutoff <- sum(df_ggplot$logMaxIntensity >= log_cutoff)
total_points <- nrow(df_ggplot)
per_above_int_cutoff <- num_above_cutoff / total_points * 100
# Print both number and percentage
cat(sprintf(
"Number of points above log10(good_int_cutoff) = %.2f: %d out of %d (%.2f%%)\n",
log_cutoff,
num_above_cutoff,
total_points,
per_above_int_cutoff
))
# Create the ggplot
ggplot(df_ggplot, aes(x = Index, y = logMaxIntensity)) +
geom_line() +
geom_hline(yintercept = log_cutoff, color = "red", linetype = "dashed", size = 1) +
labs(
x = "Index",
y = "log10(Max intensity_sub_b)",
title = "Spread of log10(Max intensity_sub_b)",
subtitle = sprintf("Red dashed line: log10(good_int_cutoff) = %.2f", log_cutoff)
) +
theme_minimal()
# rm all temp files to release RAM
rm(df_by_slice_M0M1M2_modified)
rm(df_by_slice_M0M1_modified)
rm(expression)
rm(log_max_intensity_sub_b)
rm(max_intensity_sub_b)
rm(calculate_medians)
rm(calculate_max_mn_intensity)
rm(df_ggplot)
# rm all temp files to release RAM
rm(df_by_slice_M0M1M2_modified)
rm(df_by_slice_M0M1_modified)
rm(expression)
rm(log_max_intensity_sub_b)
rm(max_intensity_sub_b)
rm(calculate_medians)
rm(calculate_max_mn_intensity)
rm(df_ggplot)
# Additional check on by slice data row that the observed M0M1M2 intensity if very far away from true ratio:
# If the highest Mn ratio is at least 0.1 higher than other Mn ratios but the observed intensity is not the max among all mn intensity,
# that row of by slice data is discarded before training as the true intensity cannot be determined
# Function to check the condition
check_highest_predicted <- function(row) {
max_predicted <- which.max(c(row$m0_predicted, row$m1_predicted, row$m2_predicted))
predicted_values <- c(row$m0_predicted, row$m1_predicted, row$m2_predicted)
sorted_indices <- order(predicted_values, decreasing = TRUE)
max_index <- sorted_indices[1]
second_max_index <- sorted_indices[2]
if (row$integrated_to_area == 1) {
if (predicted_values[max_index] - predicted_values[second_max_index] < 0.1) {
if ((max_index == 1 && (row$m0_intensity >= row$m1_intensity & row$m0_intensity >= row$m2_intensity)) ||
(max_index == 2 && (row$m1_intensity >= row$m0_intensity & row$m1_intensity >= row$m2_intensity)) ||
(max_index == 3 && (row$m2_intensity >= row$m0_intensity & row$m2_intensity >= row$m1_intensity)) ||
(second_max_index == 1 && (row$m0_intensity >= row$m1_intensity & row$m0_intensity >= row$m2_intensity)) ||
(second_max_index == 2 && (row$m1_intensity >= row$m0_intensity & row$m1_intensity >= row$m2_intensity)) ||
(second_max_index == 3 && (row$m2_intensity >= row$m0_intensity & row$m2_intensity >= row$m1_intensity))) {
return(TRUE)
} else {
return(FALSE)
}
} else {
if ((max_index == 1 && (row$m0_intensity >= row$m1_intensity & row$m0_intensity >= row$m2_intensity)) ||
(max_index == 2 && (row$m1_intensity >= row$m0_intensity & row$m1_intensity >= row$m2_intensity)) ||
(max_index == 3 && (row$m2_intensity >= row$m0_intensity & row$m2_intensity >= row$m1_intensity))) {
return(TRUE)
} else {
return(FALSE)
}
}
} else {
if (predicted_values[max_index] - predicted_values[second_max_index] < 0.1) {
if ((max_index == 1 && row$m0_intensity >= row$m1_intensity) ||
(max_index == 2 && row$m1_intensity >= row$m0_intensity) ||
(second_max_index == 1 && row$m0_intensity >= row$m1_intensity) ||
(second_max_index == 2 && row$m1_intensity >= row$m0_intensity)) {
return(TRUE)
} else {
return(FALSE)
}
} else {
if ((max_index == 1 && row$m0_intensity >= row$m1_intensity) ||
(max_index == 2 && row$m1_intensity >= row$m0_intensity)) {
return(TRUE)
} else {
return(FALSE)
}
}
}
}
# Create a new dataframe with the additional check_result column
df_by_slice_combined_checked <- df_by_slice_combined %>%
rowwise() %>%
mutate(check_result = check_highest_predicted(cur_data())) %>%
ungroup()
# Filter the rows where check_result is FALSE and save in a separate dataframe
df_by_slice_combined_false <- df_by_slice_combined_checked %>%
filter(check_result == FALSE)
df_by_slice_combined <- df_by_slice_combined_checked %>%
filter(check_result == TRUE) %>%
select(-check_result)
rm(df_by_slice_combined_checked)
rm(check_highest_predicted)
# Create df_by_mn_high and df_by_mn_low based on if its signal is above or below the determined good_int_cutoff which is used for rf training
# For each slice of df_by_mn_high, the highest mn signal will be used to calculate the true intensity of other Mn signals
# For each slice of df_by_mn_low, they will not be used in the first model training of step 2c as its highest intensity is still off,
# Only after the intial traing, these data will be added for further training, after its true inetnsity be predicted by the inital model
# Function to generate new rows with the highest intensity parameter
generate_new_rows <- function(compound, sample, formula, rt_left, rt_peak, rt_right, slice_rt, slice, total_slices, slice_peak_height, reference_mz, precursor_mz, m1_mz, m2_mz, total_ion, total_ion_smoothed, m0_intensity, m1_intensity, m2_intensity = NA, m0_intensity_smoothed, m1_intensity_smoothed, m2_intensity_smoothed = NA, m0_baseline, m1_baseline, m2_baseline = NA, m0_noise, m1_noise, m2_noise = NA, mminus1_to_m0_intensity, m0_to_m1_intensity, m1_to_m2_intensity, m2_to_m3_intensity = NA, m3_intensity = NA, m3_intensity_smoothed = NA, m0_intensity_sub_b, m1_intensity_sub_b, m2_intensity_sub_b = NA, m0_intensity_smoothed_sub_b, m1_intensity_smoothed_sub_b, m2_intensity_smoothed_sub_b = NA, m0_predicted, m1_predicted, m2_predicted = NA, integrated_to_area, source) {
highest_original_intensity <- max(m0_intensity, m1_intensity, m2_intensity, na.rm = TRUE)
if (source == "M0M1M2") {
if (highest_original_intensity >= good_int_cutoff) {
if (m0_intensity == highest_original_intensity) {
new_rows <- data.frame(
compound = rep(compound, 3),
sample = rep(sample, 3),
formula = rep(formula, 3),
mn = c(0, 1, 2),
rt_left = rep(rt_left, 3),
rt_peak = rep(rt_peak, 3),
rt_right = rep(rt_right, 3),
slice_rt = rep(slice_rt, 3),
slice = rep(slice, 3),
total_slices = rep(total_slices, 3),
slice_peak_height = rep(slice_peak_height, 3),
reference_mz = rep(reference_mz, 3),
mn_mz = c(precursor_mz, m1_mz, m2_mz),
total_ion = rep(total_ion, 3),
total_ion_smoothed = rep(total_ion_smoothed, 3),
mn_intensity = c(m0_intensity, m1_intensity, m2_intensity),
mn_intensity_smoothed = c(m0_intensity_smoothed, m1_intensity_smoothed, m2_intensity_smoothed),
mn_baseline = c(m0_baseline, m1_baseline, m2_baseline),
mn_noise = c(m0_noise, m1_noise, m2_noise),
mnminus1_to_mn_intensity = c(mminus1_to_m0_intensity, m0_to_m1_intensity, m1_to_m2_intensity),
mn_to_mplus1_intensity = c(m0_to_m1_intensity, m1_to_m2_intensity, m2_to_m3_intensity),
mplus1_intensity = c(m1_intensity, m2_intensity, m3_intensity),
mplus1_intensity_smoothed = c(m1_intensity_smoothed, m2_intensity_smoothed, m3_intensity_smoothed),
intensity_predicted = c(m0_intensity_sub_b, (m0_intensity_sub_b * m1_predicted) / m0_predicted, (m0_intensity_sub_b * m2_predicted) / m0_predicted),
intensity_smoothed_predicted = c(m0_intensity_smoothed_sub_b, (m0_intensity_smoothed_sub_b * m1_predicted) / m0_predicted, (m0_intensity_smoothed_sub_b * m2_predicted) / m0_predicted),
ratio = c(NA, NA, NA),
highest_original_intensity = highest_original_intensity
)
} else if (m1_intensity == highest_original_intensity) {
new_rows <- data.frame(
compound = rep(compound, 3),
sample = rep(sample, 3),
formula = rep(formula, 3),
mn = c(0, 1, 2),
rt_left = rep(rt_left, 3),
rt_peak = rep(rt_peak, 3),
rt_right = rep(rt_right, 3),
slice_rt = rep(slice_rt, 3),
slice = rep(slice, 3),
total_slices = rep(total_slices, 3),
slice_peak_height = rep(slice_peak_height, 3),
reference_mz = rep(reference_mz, 3),
mn_mz = c(precursor_mz, m1_mz, m2_mz),
total_ion = rep(total_ion, 3),
total_ion_smoothed = rep(total_ion_smoothed, 3),
mn_intensity = c(m0_intensity, m1_intensity, m2_intensity),
mn_intensity_smoothed = c(m0_intensity_smoothed, m1_intensity_smoothed, m2_intensity_smoothed),
mn_baseline = c(m0_baseline, m1_baseline, m2_baseline),
mn_noise = c(m0_noise, m1_noise, m2_noise),
mnminus1_to_mn_intensity = c(mminus1_to_m0_intensity, m0_to_m1_intensity, m1_to_m2_intensity),
mn_to_mplus1_intensity = c(m0_to_m1_intensity, m1_to_m2_intensity, m2_to_m3_intensity),
mplus1_intensity = c(m1_intensity, m2_intensity, m3_intensity),
mplus1_intensity_smoothed = c(m1_intensity_smoothed, m2_intensity_smoothed, m3_intensity_smoothed),
intensity_predicted = c((m1_intensity_sub_b * m0_predicted) / m1_predicted, m1_intensity_sub_b, (m1_intensity_sub_b * m2_predicted) / m1_predicted),
intensity_smoothed_predicted = c((m1_intensity_smoothed_sub_b * m0_predicted) / m1_predicted, m1_intensity_smoothed_sub_b, (m1_intensity_smoothed_sub_b * m2_predicted) / m1_predicted),
ratio = c(NA, NA, NA),
highest_original_intensity = highest_original_intensity
)
} else if (m2_intensity == highest_original_intensity) {
new_rows <- data.frame(
compound = rep(compound, 3),
sample = rep(sample, 3),
formula = rep(formula, 3),
mn = c(0, 1, 2),
rt_left = rep(rt_left, 3),
rt_peak = rep(rt_peak, 3),
rt_right = rep(rt_right, 3),
slice_rt = rep(slice_rt, 3),
slice = rep(slice, 3),
total_slices = rep(total_slices, 3),
slice_peak_height = rep(slice_peak_height, 3),
reference_mz = rep(reference_mz, 3),
mn_mz = c(precursor_mz, m1_mz, m2_mz),
total_ion = rep(total_ion, 3),
total_ion_smoothed = rep(total_ion_smoothed, 3),
mn_intensity = c(m0_intensity, m1_intensity, m2_intensity),
mn_intensity_smoothed = c(m0_intensity_smoothed, m1_intensity_smoothed, m2_intensity_smoothed),
mn_baseline = c(m0_baseline, m1_baseline, m2_baseline),
mn_noise = c(m0_noise, m1_noise, m2_noise),
mnminus1_to_mn_intensity = c(mminus1_to_m0_intensity, m0_to_m1_intensity, m1_to_m2_intensity),
mn_to_mplus1_intensity = c(m0_to_m1_intensity, m1_to_m2_intensity, m2_to_m3_intensity),
mplus1_intensity = c(m1_intensity, m2_intensity, m3_intensity),
mplus1_intensity_smoothed = c(m1_intensity_smoothed, m2_intensity_smoothed, m3_intensity_smoothed),
intensity_predicted = c((m2_intensity_sub_b * m0_predicted) / m2_predicted, (m2_intensity_sub_b * m1_predicted) / m2_predicted, m2_intensity_sub_b),
intensity_smoothed_predicted = c((m2_intensity_smoothed_sub_b * m0_predicted) / m2_predicted, (m2_intensity_smoothed_sub_b * m1_predicted) / m2_predicted, m2_intensity_smoothed_sub_b),
ratio = c(NA, NA, NA),
highest_original_intensity = highest_original_intensity
)
}
} else {
new_rows <- data.frame(
compound = rep(compound, 3),
sample = rep(sample, 3),
formula = rep(formula, 3),
mn = c(0, 1, 2),
rt_left = rep(rt_left, 3),
rt_peak = rep(rt_peak, 3),
rt_right = rep(rt_right, 3),
slice_rt = rep(slice_rt, 3),
slice = rep(slice, 3),
total_slices = rep(total_slices, 3),
slice_peak_height = rep(slice_peak_height, 3),
reference_mz = rep(reference_mz, 3),
mn_mz = c(precursor_mz, m1_mz, m2_mz),
total_ion = rep(total_ion, 3),
total_ion_smoothed = rep(total_ion_smoothed, 3),
mn_intensity = c(m0_intensity, m1_intensity, m2_intensity),
mn_intensity_smoothed = c(m0_intensity_smoothed, m1_intensity_smoothed, m2_intensity_smoothed),
mn_baseline = c(m0_baseline, m1_baseline, m2_baseline),
mn_noise = c(m0_noise, m1_noise, m2_noise),
mnminus1_to_mn_intensity = c(mminus1_to_m0_intensity, m0_to_m1_intensity, m1_to_m2_intensity),
mn_to_mplus1_intensity = c(m0_to_m1_intensity, m1_to_m2_intensity, m2_to_m3_intensity),
mplus1_intensity = c(m1_intensity, m2_intensity, m3_intensity),
mplus1_intensity_smoothed = c(m1_intensity_smoothed, m2_intensity_smoothed, m3_intensity_smoothed),
intensity_predicted = c(NA, NA, NA),
intensity_smoothed_predicted = c(NA, NA, NA),
ratio = c(m0_predicted, m1_predicted, m2_predicted),
highest_original_intensity = highest_original_intensity
)
}
} else if (source == "M0M1") {
highest_original_intensity <- max(m0_intensity, m1_intensity, na.rm = TRUE)
if (highest_original_intensity >= good_int_cutoff) {
if (m0_intensity >= m1_intensity) {
new_rows <- data.frame(
compound = rep(compound, 2),
sample = rep(sample, 2),
formula = rep(formula, 2),
mn = c(0, 1),
rt_left = rep(rt_left, 2),
rt_peak = rep(rt_peak, 2),
rt_right = rep(rt_right, 2),
slice_rt = rep(slice_rt, 2),
slice = rep(slice, 2),
total_slices = rep(total_slices, 2),
slice_peak_height = rep(slice_peak_height, 2),
reference_mz = rep(reference_mz, 2),
mn_mz = c(precursor_mz, m1_mz),
total_ion = rep(total_ion, 2),
total_ion_smoothed = rep(total_ion_smoothed, 2),
mn_intensity = c(m0_intensity, m1_intensity),
mn_intensity_smoothed = c(m0_intensity_smoothed, m1_intensity_smoothed),
mn_baseline = c(m0_baseline, m1_baseline),
mn_noise = c(m0_noise, m1_noise),
mnminus1_to_mn_intensity = c(mminus1_to_m0_intensity, m0_to_m1_intensity),
mn_to_mplus1_intensity = c(m0_to_m1_intensity, m1_to_m2_intensity),
mplus1_intensity = c(m1_intensity, m2_intensity),
mplus1_intensity_smoothed = c(m1_intensity_smoothed, m2_intensity_smoothed),
intensity_predicted = c(m0_intensity_sub_b, (m0_intensity_sub_b * m1_predicted) / m0_predicted),
intensity_smoothed_predicted = c(m0_intensity_smoothed_sub_b, (m0_intensity_smoothed_sub_b * m1_predicted) / m0_predicted),
ratio = c(NA, NA),
highest_original_intensity = highest_original_intensity
)
} else if (m1_intensity >= m0_intensity) {
new_rows <- data.frame(
compound = rep(compound, 2),
sample = rep(sample, 2),
formula = rep(formula, 2),
mn = c(0, 1),
rt_left = rep(rt_left, 2),
rt_peak = rep(rt_peak, 2),
rt_right = rep(rt_right, 2),
slice_rt = rep(slice_rt, 2),
slice = rep(slice, 2),
total_slices = rep(total_slices, 2),
slice_peak_height = rep(slice_peak_height, 2),
reference_mz = rep(reference_mz, 2),
mn_mz = c(precursor_mz, m1_mz),
total_ion = rep(total_ion, 2),
total_ion_smoothed = rep(total_ion_smoothed, 2),
mn_intensity = c(m0_intensity, m1_intensity),
mn_intensity_smoothed = c(m0_intensity_smoothed, m1_intensity_smoothed),
mn_baseline = c(m0_baseline, m1_baseline),
mn_noise = c(m0_noise, m1_noise),
mnminus1_to_mn_intensity = c(mminus1_to_m0_intensity, m0_to_m1_intensity),
mn_to_mplus1_intensity = c(m0_to_m1_intensity, m1_to_m2_intensity),
mplus1_intensity = c(m1_intensity, m2_intensity),
mplus1_intensity_smoothed = c(m1_intensity_smoothed, m2_intensity_smoothed),
intensity_predicted = c((m1_intensity_sub_b * m0_predicted) / m1_predicted, m1_intensity_sub_b),
intensity_smoothed_predicted = c((m1_intensity_smoothed_sub_b * m0_predicted) / m1_predicted, m1_intensity_smoothed_sub_b),
ratio = c(NA, NA),
highest_original_intensity = highest_original_intensity
)
}
} else {
new_rows <- data.frame(
compound = rep(compound, 2),
sample = rep(sample, 2),
formula = rep(formula, 2),
mn = c(0, 1),
rt_left = rep(rt_left, 2),
rt_peak = rep(rt_peak, 2),
rt_right = rep(rt_right, 2),
slice_rt = rep(slice_rt, 2),
slice = rep(slice, 2),
total_slices = rep(total_slices, 2),
slice_peak_height = rep(slice_peak_height, 2),
reference_mz = rep(reference_mz, 2),
mn_mz = c(precursor_mz, m1_mz),
total_ion = rep(total_ion, 2),
total_ion_smoothed = rep(total_ion_smoothed, 2),
mn_intensity = c(m0_intensity, m1_intensity),
mn_intensity_smoothed = c(m0_intensity_smoothed, m1_intensity_smoothed),
mn_baseline = c(m0_baseline, m1_baseline),
mn_noise = c(m0_noise, m1_noise),
mnminus1_to_mn_intensity = c(mminus1_to_m0_intensity, m0_to_m1_intensity),
mn_to_mplus1_intensity = c(m0_to_m1_intensity, m1_to_m2_intensity),
mplus1_intensity = c(m1_intensity, m2_intensity),
mplus1_intensity_smoothed = c(m1_intensity_smoothed, m2_intensity_smoothed),
intensity_predicted = c(NA, NA),
intensity_smoothed_predicted = c(NA, NA),
ratio = c(m0_predicted / (m0_predicted + m1_predicted), m1_predicted / (m0_predicted + m1_predicted)),
highest_original_intensity = highest_original_intensity
)
}
}
return(new_rows)
}
# Add a source column to tell the function generate_new_rows how to process
df_by_slice_M0M1M2 <- df_by_slice_M0M1M2 %>%
mutate(source = "M0M1M2")
df_by_slice_M0M1 <- df_by_slice_M0M1 %>%
mutate(source = "M0M1")
# Select the relevant columns from the original data frames including the new parameters
df_selected_M0M1M2 <- df_by_slice_M0M1M2 %>%
select(compound, sample, formula, rt_left, rt_peak, rt_right, slice_rt, slice, total_slices, slice_peak_height, reference_mz, precursor_mz, m1_mz, m2_mz, total_ion, total_ion_smoothed,
m0_intensity, m1_intensity, m2_intensity, m0_intensity_smoothed, m1_intensity_smoothed, m2_intensity_smoothed, m0_baseline, m1_baseline, m2_baseline, m0_noise, m1_noise, m2_noise,
mminus1_to_m0_intensity, m0_to_m1_intensity, m1_to_m2_intensity, m2_to_m3_intensity, m3_intensity, m3_intensity_smoothed, m0_intensity_sub_b, m1_intensity_sub_b, m2_intensity_sub_b,
m0_intensity_smoothed_sub_b, m1_intensity_smoothed_sub_b, m2_intensity_smoothed_sub_b, m0_predicted, m1_predicted, m2_predicted, integrated_to_area, source)
df_selected_M0M1 <- df_by_slice_M0M1 %>%
select(compound, sample, formula, rt_left, rt_peak, rt_right, slice_rt, slice, total_slices, slice_peak_height, reference_mz, precursor_mz, m1_mz, total_ion, total_ion_smoothed,
m0_intensity, m1_intensity, m2_intensity, m0_intensity_smoothed, m1_intensity_smoothed, m2_intensity_smoothed, m0_baseline, m1_baseline, m0_noise, m1_noise,
mminus1_to_m0_intensity, m0_to_m1_intensity, m1_to_m2_intensity, m2_to_m3_intensity, m0_intensity_sub_b, m1_intensity_sub_b, m0_intensity_smoothed_sub_b, m1_intensity_smoothed_sub_b, m0_predicted, m1_predicted, integrated_to_area, source)
# Apply the function generate_new_rows to each row of the selected data frames using pmap
df_by_mn_M0M1M2 <- pmap_dfr(df_selected_M0M1M2, generate_new_rows)
df_by_mn_M0M1 <- pmap_dfr(df_selected_M0M1, generate_new_rows)
# Combine the new rows from both data frames
df_by_mn <- bind_rows(df_by_mn_M0M1M2, df_by_mn_M0M1)
# Separate the new rows into high and low intensity data frames
df_by_mn_high <- df_by_mn %>% filter(highest_original_intensity >= good_int_cutoff)
df_by_mn_low <- df_by_mn %>% filter(highest_original_intensity < good_int_cutoff)
rm(df_selected_M0M1)
rm(df_selected_M0M1M2)
rm(generate_new_rows)
#######################################
# # Optional Check: Identify rows where M0_predicted is less than M1_predicted or less than M2_predicted
# rows_M0_less_than_M1_or_M2 <- which(df_by_slice_M0M1M2$m0_predicted < df_by_slice_M0M1M2$m1_predicted |
#                                     df_by_slice_M0M1M2$m0_predicted < df_by_slice_M0M1M2$m2_predicted)
#
# cat("Rows where M0_predicted is less than M1_predicted or less than M2_predicted:\n")
# print(rows_M0_less_than_M1_or_M2)
# cat("Details of rows where M0_predicted is less than M1_predicted or less than M2_predicted:\n")
# print(df_by_slice_M0M1M2[rows_M0_less_than_M1_or_M2, ])
###########################################
# Should check which cols have NA values and replace them!
high_columns_with_na <- names(df_by_mn_high)[sapply(df_by_mn_high, function(x) sum(is.na(x)) > 0)]
low_columns_with_na <- names(df_by_mn_low)[sapply(df_by_mn_low, function(x) sum(is.na(x)) > 0)]
# Calculate the median of mn_noise excluding NA values
median_mn_noise <- median(df_by_mn$mn_noise, na.rm = TRUE)
# Replace NA values in mn_noise with the calculated median
df_by_mn_high$mn_noise[is.na(df_by_mn_high$mn_noise)] <- median_mn_noise
df_by_mn_low$mn_noise[is.na(df_by_mn_low$mn_noise)] <- median_mn_noise
df_by_mn_high$rt_width <- df_by_mn_high$rt_right - df_by_mn_high$rt_left
df_by_mn_low$rt_width <- df_by_mn_low$rt_right - df_by_mn_low$rt_left
df_by_mn_high$slice_diff_to_m0peak <- df_by_mn_high$slice - df_by_mn_high$slice_peak_height
df_by_mn_low$slice_diff_to_m0peak <- df_by_mn_low$slice - df_by_mn_low$slice_peak_height
df_by_mn_high$mz_to_center <- abs(df_by_mn_high$mn_mz - (69+360)/2)
df_by_mn_low$mz_to_center <- abs(df_by_mn_low$mn_mz - (69+360)/2)
df_by_mn_high$intensity_over_TIC  <- df_by_mn_high$mn_intensity/df_by_mn_high$total_ion
df_by_mn_low$intensity_over_TIC  <- df_by_mn_low$mn_intensity/df_by_mn_low$total_ion
df_by_mn_high$intensity_over_TIC_smoothed  <- df_by_mn_high$mn_intensity_smoothed/df_by_mn_high$total_ion_smoothed
df_by_mn_low$intensity_over_TIC_smoothed  <- df_by_mn_low$mn_intensity_smoothed/df_by_mn_low$total_ion_smoothed
df_by_mn_high$intensity_minus_bg  <- df_by_mn_high$mn_intensity - df_by_mn_high$mn_baseline
df_by_mn_low$intensity_minus_bg  <- df_by_mn_low$mn_intensity - df_by_mn_low$mn_baseline
df_by_mn_high$intensity_minus_bg_smoothed  <- df_by_mn_high$mn_intensity_smoothed - df_by_mn_high$mn_baseline
df_by_mn_low$intensity_minus_bg_smoothed  <- df_by_mn_low$mn_intensity_smoothed - df_by_mn_low$mn_baseline
df_by_mn_high$intensity_over_bg  <- df_by_mn_high$mn_intensity / (df_by_mn_high$mn_baseline + epsilon)
df_by_mn_low$intensity_over_bg  <- df_by_mn_low$mn_intensity / (df_by_mn_low$mn_baseline + epsilon)
df_by_mn_high$intensity_over_ns  <- df_by_mn_high$mn_intensity / (df_by_mn_high$mn_noise + epsilon)
df_by_mn_low$intensity_over_ns  <- df_by_mn_low$mn_intensity / (df_by_mn_low$mn_noise + epsilon)
# Function to count elements number from formula, be aware that it has different name and output format as 1c functions
countelements <- function(inputformula) {
elements <- c("H", "C", "N", "O", "S", "P", "Si")
counts <- setNames(numeric(length(elements)), elements)
formula <- gsub("Si", "Xx", inputformula)
for (element in elements) {
search_el <- if (element == "Si") "Xx" else element
pattern <- paste0(search_el, "(\\d*)")
raw_matches <- regmatches(formula, gregexpr(pattern, formula, perl = TRUE))[[1]]
if (length(raw_matches) > 0) {
# Extract numbers; implied '1' if empty eg: CO2 means C1O2
nums <- vapply(raw_matches, function(x) {
val <- sub(search_el, "", x)
if (val == "") 1 else as.numeric(val)
}, numeric(1))
counts[element] <- sum(nums)
}
}
return(counts)
}
# Function to add element count cols
add_element_counts <- function(df) {
required_columns <- c("H", "C", "N", "O", "S", "P", "Si")
df <- df[, !(names(df) %in% required_columns), drop = FALSE]
element_counts <- t(sapply(df$formula, countelements))
element_counts <- as.data.frame(element_counts)
df <- cbind(df, element_counts)
df$atom_number <- rowSums(df[required_columns], na.rm = TRUE)
return(df)
}
df_by_mn_high <- add_element_counts(df_by_mn_high)
df_by_mn_low <- add_element_counts(df_by_mn_low)
rm(add_element_counts)
rm(countelements)
##########################################################
# Now we will save and summary the preprocessed data
save(df, file = "df_2b.RData")
save(df_by_mn_high, file = "df_by_mn_high_2b.RData")
save(df_by_mn_low, file = "df_by_mn_low_2b.RData")
df_by_slice <- df_by_slice_combined
save(df_by_slice, file = "df_by_slice_2b.RData")
# Print summary
red <- function(x) paste0("\033[31m", x, "\033[0m")
good_cutoff_str <- red(sprintf("%.2e", good_int_cutoff))
error_cutoff_str <- red(sprintf("%.2f", percentage_error_cutoff))
log_cutoff_str <- red(sprintf("%.2f", log_cutoff))
num_above_str <- red(sprintf("%d", num_above_cutoff))
total_str <- red(sprintf("%d", total_points))
percent_str <- red(sprintf("%.2f%%", per_above_int_cutoff))
cat(
"DATA STATS SUMMARY:\n",
sprintf("• In this input data set, If two Mn signals of a slice are both >= %s,", good_cutoff_str), "\n",
sprintf("  their median percentage relative ratio error will be within +-%s.", error_cutoff_str), "\n",
sprintf("• Therefore, %s is chosen as the cutoff to decide if a Mn signal intesntiy is accurate.", good_cutoff_str), "\n",
"  Accurate signals need no bias correction and can help compute true intensity\n",
"  of other Mn signals based on predicted MID (Mass Isotopomer Distribution).\n",
sprintf("• %s out of %s slices (before ratio checks) have Mn signals above this cutoff (%s).\n", num_above_str, total_str, percent_str),
sprintf("• %s intensity cutoff based df_by_mn_high and df_by_mn_low data \n", good_cutoff_str),
"  along with the filtered df and df by slice has been saved,\n",
"  please continue either step 2cRF or 2cEN bias correction model training.\n"
)
rm(df_by_slice_combined)
rm(df_raw)
rm(df_removed)
rm(df_by_slice_raw)
